### :link: 2025-07-22
- [예외 처리 개념](#1-예외-처리-개념)
- [Spring Boot 환경에서의 예외 처리](#2-spring-boot-환경에서의-예외-처리)
- [예외 처리 시 주의점](#3-예외-처리-시-주의점)
 
&nbsp;
### 1. 예외 처리 개념

#### 1) 예외(Exception)란?
- 프로그램 실행 중 발생할 수 있는 비정상적인 상황을 객체로 표현한 것
- 문제가 생긴 위치와 원인을 추적할 수 있도록 해줌
- 대표적으로 `NullPointerException`, `IllegalArgumentException` 등이 있음

#### 2) Checked vs Unchecked
- Checked Exception: 컴파일 타임에 처리 강제됨 (`IOException`, `SQLException`)  
- Unchecked Exception: 런타임 시점에 발생, 처리 선택 가능 (`NullPointerException`, `IllegalStateException`)  
- 대부분의 Spring 프로젝트에서는 Unchecked Exception을 사용함

#### 3) try-catch-finally
```java
try {
  int result = 10 / 0;
} catch (ArithmeticException e) {
  System.out.println("0으로 나눌 수 없음");
} finally {
  System.out.println("항상 실행됨");
}
```

- try 안에 예외 발생 가능 코드  
- catch 블럭에서 구체적인 예외를 받아 처리  
- finally는 예외 발생 여부와 관계없이 항상 실행됨  

---

### 2. Spring Boot 환경에서의 예외 처리

#### 1) 전역 예외 처리 클래스 (@RestControllerAdvice)
- 컨트롤러 단에서 발생한 예외를 하나의 클래스에서 처리하게 해줌
- 프로젝트 전체에 적용 가능

```java
@RestControllerAdvice
public class GlobalExceptionHandler {

  @ExceptionHandler(IllegalArgumentException.class)
  public ResponseEntity<String> handleIllegalArgument(IllegalArgumentException e) {
    return ResponseEntity.badRequest().body("잘못된 요청: " + e.getMessage());
  }
}
```

- `@ExceptionHandler`는 특정 예외 클래스 전용 핸들러  
- 응답 형태를 통일할 수 있어서 API 개발에 유리함  

#### 2) 사용자 정의 예외(Custom Exception)
- 비즈니스 로직에 맞는 의미 있는 예외를 직접 만들어 사용함

```java
public class ShopNotFoundException extends RuntimeException {
  public ShopNotFoundException(Long id) {
    super("해당 ID의 샵이 존재하지 않음: " + id);
  }
}
```

- 명확한 도메인 의미를 담아서 디버깅과 유지보수에 유리함  

#### 3) 커스텀 예외 + 전역 핸들러 조합
```java
@ExceptionHandler(ShopNotFoundException.class)
public ResponseEntity<String> handleShopNotFound(ShopNotFoundException e) {
  return ResponseEntity.status(HttpStatus.NOT_FOUND).body(e.getMessage());
}
```

- 응답 상태 코드를 상황에 맞게 설정 가능  
- 예외 메시지를 클라이언트에게 전달할 수도 있음  

#### 4) ErrorResponse DTO로 통일된 응답
```java
public class ErrorResponse {
  private int status;
  private String message;

  // 생성자, getter, setter 생략
}
```

```java
@ExceptionHandler(Exception.class)
public ResponseEntity<ErrorResponse> handleAll(Exception e) {
  ErrorResponse err = new ErrorResponse(500, e.getMessage());
  return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(err);
}
```

- 클라이언트 측에서 에러 포맷을 예측 가능하게 만들어줌  
- status, message, timestamp, path 등을 함께 담는 경우도 많음  

---

### 3. 예외 처리 시 주의점

#### 1) 예외를 삼키지 말기
```java
try {
  ...
} catch (Exception e) {
  // 아무 처리도 안 함 -> 문제 원인 추적 불가
}
```

- 최소한 로그를 남기거나 다시 던져야 함  

#### 2) 예외로 흐름 제어하지 않기
- 예외는 진짜 예외적인 상황에서만 사용해야 함  
- 조건 분기를 우선 고려하고, 실패 가능성이 낮은 코드에 try-catch를 적용해야 함  

#### 3) 예외 메시지에는 힌트를 주기
- 사용자에게는 너무 구체적인 시스템 정보 노출은 금지  
- 개발자에게는 로그에 충분한 원인 정보가 들어가야 함  

---

- Spring에서는 대부분 `RuntimeException`을 상속한 커스텀 예외를 사용
- `@RestControllerAdvice`로 예외를 통합해서 관리하면 각 컨트롤러 코드가 깔끔해짐  
- 응답 포맷을 ErrorResponse 형태로 고정하면 프론트엔드 연동 시 안정성 향상
- 실서비스에서는 예외 발생 시 로깅, 알림, 모니터링 시스템과 연계도 고려 필요
