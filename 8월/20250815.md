### :link: 2025-08-15

- [사용자 예약 동시성 문제 해결](#사용자-예약-동시성-문제-해결)
 
&nbsp; 
### 사용자 예약 동시성 문제 해결
예약에 대한 동시 요청이 발생할 경우, 데이터 조회와 삽입 사이의 시간차(Race Condition)로 인해 모든 요청이 실패하거나 데이터가 잘못 저장될 가능성이 있었다.   
이에 동일한 시간에 여러 사용자가 예약을 생성하려고 시도할 때 발생하는 동시성 문제를 해결하는 작업을 진행했다.

이 문제를 해결하기 위해 JPA의 비관적 락(Pessimistic Lock)을 도입했다. 예약 가능 여부를 확인하는 핵심 쿼리 메소드에 `@Lock(LockModeType.PESSIMISTIC_WRITE)` 어노테이션을 적용하여, 특정 예약 슬롯에 대한 트랜잭션이 진행 중일 때 다른 트랜잭션의 접근을 막았다.

```java
// ReservationRepository.java
@Lock(LockModeType.PESSIMISTIC_WRITE)
@Query("SELECT r FROM Reservation r WHERE r.shop.id = :shopId AND ...")
boolean existsByShopAndDateTimeWithLock(@Param("shopId") Long shopId, ...);
```

락 적용 결과, 100개의 동시 요청을 보냈을 때 의도했던대로 오직 하나의 요청만 예약 생성에 성공했으며, 나머지 99개의 요청은 '이미 예약된 일정'이라는 사용자 정의 예외 응답을 받도록 처리되었다.   
이를 통해 여러 사용자가 동시에 예약하는 상황에서도 데이터의 정합성을 보장할 수 있게 되었다.
 
애플리케이션 레벨의 락과 더불어, 데이터베이스 레벨에서도 중복 예약을 원천적으로 방지하기 위한 안전장치로 `UNIQUE` 제약 조건을 추가했다. 이로써 백엔드 로직에 실수가 있더라도 데이터베이스 단에서 원칙으로 중복 데이터 삽입을 막아줄 수 있을 것이다.

```sql
alter table tbl_reservation
    add constraint uniq_reservation_slot
        unique (shop_code, resv_date, resv_time);
```
 
https://github.com/BOA-with-elephant/Header-backend/pull/210