### :link: 2025-08-12

- [Spring Security URL 패턴 매칭 문제 해결](#1-spring-security-url-패턴-매칭-문제-해결)
- [시술 검색 기능 추가](#2-시술-검색-기능-추가)
 
&nbsp; 
### 1. Spring Security URL 패턴 매칭 문제 해결

상점 검색 API(`.../api/shops?query=...`)를 호출할 때, Spring Security 계층에서 해당 요청을 허용하지 않아 접근이 거부되었다.

문제의 원인은 `SecurityConfig`에 등록된 URL 패턴이었는데, 기존 설정에는 `"/api/shops/"`와 같이 마지막에 슬래시(/)가 포함된 경로만 허용되어 있었다. 쿼리 파라미터가 포함된 `"/api/shops?..."` 요청은 슬래시가 없는 `"/api/shops"` 경로로 인식되었고, 이 패턴이 허용 목록에 없었기 때문에 보안 필터에 의해 차단된 것이었다.

이에 `SecurityConfig`의 URL 허용 목록에 슬래시가 없는 `/api/shops` 경로를 명시적으로 추가했다.

```java
// SecurityConfig.java
            // auth.requestMatchers("/api/v1/shops/**").permitAll();
            auth.requestMatchers("/api/v1/shops", "/api/v1/shops/**").permitAll();
```

&emsp; 
&nbsp;
### 2. 시술 검색 기능 추가

```java
    @Query(
            value = """
        select distinct // distinct 추가
            s.shop_code as shopCode,
            s.shop_name as shopName,
            s.shop_phone as shopPhone,
            s.shop_location as shopLocation,
            s.shop_long as shopLong,
            s.shop_la as shopLa,
            sc.category_name as categoryName,
            st_distance_sphere(
                    point(s.shop_long, s.shop_la), 
                    point(:longitude, :latitude)) as distance
                
        from tbl_shop s
        join tbl_shop_category sc on s.category_code = sc.category_code
        left join tbl_menu m on m.shop_code = s.shop_code // menu join
        where (:categoryCode is null or s.category_code = :categoryCode)
          and (:keyword is null
                        or s.shop_name like %:keyword%
                        or s.shop_location like %:keyword%
                        or m.menu_name like %:keyword%) // menu 검색 기능
          and s.is_active = 1
        group by s.shop_code
        order by distance asc
        """,
            countQuery = """
        select count(distinct s.shop_code)
        from tbl_shop s
        left join tbl_menu m on m.shop_code = s.shop_code
        where s.is_active = 1
          and (:categoryCode is null or s.category_code = :categoryCode)
          and (:keyword is null
                        or s.shop_name like %:keyword%
                        or s.shop_location like %:keyword%
                        or m.menu_name like %:keyword%)
        """,
            nativeQuery = true
    )
    Page<ShopSearchSummaryResponse> findShopsByCondition(
            @Param("latitude") Double latitude,
            @Param("longitude") Double longitude,
            @Param("categoryCode") Integer categoryCode,
            @Param("keyword") String keyword,
            Pageable pageable
    );
```

- 추가된 쿼리
```java
    @Query("""
        SELECT 
                m.menuCategory.id.shopCode as shopCode,
                m.menuCode as menuCode,
                m.menuCategory.id.categoryCode as menuCategoryCode,
                m.menuName as menuName,
                COUNT(r.resvCode) as menuRevCount
        FROM Menu m
        LEFT JOIN BossReservation r ON r.menuInfo.menuCode = m.menuCode
        WHERE m.menuCategory.id.shopCode IN :shopCode
        GROUP BY m.menuCategory.id.shopCode, m.menuCode, m.menuName
        ORDER BY menuRevCount DESC
        """)
    List<MenuSummaryWithRevCount> getMenuSummaryByShopCode(
            @Param("shopCode") List<Integer> shopCode
    );
```
- 데이터 가공 과정
```java
/*샵 정보 가져오기*/
        Page<ShopSearchSummaryResponse> shopSummaryPage = shopRepository.findShopsByCondition(lat, lon, categoryCode, keyword, pageable);

        /*위에서 가져온 샵 정보에서 샵 코드를 추출하여 리스트 형태로 가공*/
        List<Integer> shopCodes = shopSummaryPage.getContent().stream()
                .map(ShopSearchSummaryResponse::getShopCode)
                .collect(Collectors.toList());

        /*메뉴 정보와 메뉴 예약 누적 수를 합한 결과를 리스트 형태로 가져오기*/
        List<MenuSummaryWithRevCount> allMenus = menuRepository.getMenuSummaryByShopCode(shopCodes);

        /*위에서 가져온 메뉴 및 메뉴 예약 수를 맵에 담기*/
        Map<Integer, List<MenuSummaryWithRevCount>> shopMenus = allMenus.stream()
                .collect(Collectors.groupingBy(MenuSummaryWithRevCount::getShopCode));

        /*샵 정보와 메뉴 정보를 리스트로 가공하기*/
        List<ShopWithMenusSummaryDTO> responseList = shopSummaryPage.getContent().stream()
                .map(shop -> {
                    ShopWithMenusSummaryDTO response
                            = new ShopWithMenusSummaryDTO(
                            shop.getShopCode(),
                            shop.getShopName(),
                            shop.getShopPhone(),
                            shop.getShopLocation(),
                            shop.getShopLong(),
                            shop.getShopLa(),
                            shop.getCategoryName(),
                            shop.getDistance());

                    List<MenuSummaryWithRevCount> menus = shopMenus.getOrDefault(shop.getShopCode(), Collections.emptyList());
                    menus.sort(Comparator.comparing(MenuSummaryWithRevCount::getMenuRevCount).reversed()); // 메뉴 예약순 정렬
                    response.setMenus(menus);
                    return response;
                }).collect(Collectors.toList());

        /*가공한 정보를 페이징 가능한 객체로 반환*/
        return new PageImpl<>(responseList, shopSummaryPage.getPageable(), shopSummaryPage.getTotalElements());
```

https://github.com/BOA-with-elephant/Header-backend/pull/185