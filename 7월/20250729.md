### :link: 2025-07-29
- [Python 활용](#python-활용)
 
&nbsp;
### Python 활용
#### 1) OpenAI SDK

```python
from openai import OpenAI
import os
from dotenv import load_dotenv

load_dotenv()
api_key = os.getenv("OPENAI_API_KEY")
client = OpenAI(api_key=api_key)

response = client.chat.completions.create(
    model = "gpt-3.5-turbo",
    messages=[
        {
            "role": "user",
            "content": "파이썬 SDK에 대해 50자 이내로 설명해줘."
        }
    ],
    temperature=1.0
)

sdk_answer = response.choices[0].message.content
print("\n SDK를 이용한 LLM의 답변")
print(sdk_answer)
```

#### 2) 기본 함수와 타입 힌트

```python
def create_greeting(name: str, age: int = 20) -> str:
    """이 함수는 이름과 나이를 받아 인사말을 생성합니다."""
    return f"안녕하세요, {age}세 {name}님"

print(create_greeting("cillian", 30))
print(create_greeting(age=45, name="신사임당"))
print(create_greeting("데이먼"))
```

* `name: str` → 매개변수 타입 힌트
* `age: int = 20` → 기본값 지정
* `-> str` → 반환값 타입 힌트
* `"""문서형 주석 (docstring)"""` → 함수 설명용

#### 3) 가변 인자 (\*args), 키워드 가변 인자 (\*\*kwargs)

```python
def call_llm_api(prompt: str, *args, **kwargs):
    print(f"전송할 프롬프트: '{prompt}")
    if args:
        print(f"부가옵션(tupel): {args}")
    if kwargs:
        print(f"상세 설정(dict): {kwargs}")

call_llm_api(
    "오늘의 주요 뉴스 요약해줘",
    "3줄 요약",
    model="gpt-4o",
    temperature=0.7
)
```

* `*args` → 남는 인자들을 튜플로 받음
* `**kwargs` → 남는 키워드 인자들을 딕셔너리로 받음

#### 4) JSON 데이터 저장

```python
import json

structured_data = [
    {
        "id": 1,
        "category": "python",
        "question": "파이썬의 장점은?",
        "answer": "간결한 문법과 강력한 라이브러리 생태계입니다.",
        "tags": ["python", "programming", "strength"]
    },
    {
        "id": 2,
        "category": "python",
        "question": "리스트와 튜플의 차이는?",
        "answer": "리스트는 가변(mutable)하고, 튜플은 불변(immutable)합니다.",
        "tags": ["list", "tuple", "data_structure"]
    }
]

output_filename = 'structured_data.json'
print(f"'{output_filename}' 파일로 데이터를 저장합니다.")

try:
    with open(output_filename, 'w', encoding='utf-8') as f:
        json.dump(structured_data, f, indent=2, ensure_ascii=False)
    print("파일 저장이 완료되었습니다.")
except Exception as e:
    print(f"파일 저장 중 오류 발생: {e}")
```

* `with open(filename, 'w') as f:` → 파일 안전하게 열기
* `json.dump(data, f, indent=2, ensure_ascii=False)` → JSON 저장
* `ensure_ascii=False` → 한글 깨짐 방지

#### 5) 모듈 활용
#### my_parser.py

```python
def parse_qa_data_to_list(file_path: str) -> list[dict]:
    """ 텍스트 파일을 읽어와서, Q&A 딕셔너리들의 리스트로 변환하는 함수입니다. """
    qa_list = []
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()

        blocks = content.strip().split('===')  # Q&A 블록 나누기

        for block in blocks:
            if not block.strip(): continue  # 빈 블록은 무시
            lines = block.strip().split('\n')  # 줄 단위로 나누기
            if len(lines) >= 2:
                question = lines[0].replace('Q:', '').strip()
                answer = lines[1].replace("A:", '').strip()
                if question and answer:
                    qa_list.append({"question": question, "answer": answer})
    except FileNotFoundError:
        print("파일을 찾을 수 없습니다.")
    except Exception as e:
        print("처리 중 오류 발생 : {e}")
    return qa_list
```

- `open()`, `read()`: 파일 읽기
- `strip()`, `split()`: 문자열 전처리
- 리스트에 딕셔너리 형태로 데이터 씀

#### main.py

```python
from my_parser import parse_qa_data_to_list  # 외부 모듈에서 함수 임포트
import os
import json

def run_pipeline():
    """ 전체 데이터 처리 파이프라인을 실행하는 메인 함수 """
    print("텍스트를 JSON으로 변환하는 파이프라인 시작")

    base_dir = os.path.dirname(os.path.abspath(__file__))  # 현재 파일의 절대 경로 구하기
    input_file_path = os.path.join(base_dir, 'data', 'qa_data.txt')  # 입력 파일 경로 설정
    output_file_path = os.path.join(base_dir, 'qna_for_llm.json')  # 출력 파일 경로 설정

    qa_data = parse_qa_data_to_list(input_file_path)  # 텍스트 데이터를 파싱하여 리스트로 변환

    if qa_data:
        try:
            print(f"{output_file_path}(으)로 데이터를 저장합니다.")
            with open(output_file_path, 'w', encoding='utf-8') as f:
                json.dump(qa_data, f, indent=2, ensure_ascii=False)  # 리스트를 JSON 파일로 저장
            print(f"데이터가 성공적으로 저장되었습니다.")
        except Exception as e:
            print(f"파일 저장 중 오류 발생 {e}")
    else:
        print("처리할 유효한 데이터가 없습니다.")

if __name__ == '__main__':
    run_pipeline()  # 해당 파일이 실행될 때만 run_pipeline 실행
```

- `os.path`: 경로를 절대경로/상대경로로 연결
- `json.dump`: 파이썬 객체를 JSON 파일로 저장
- `if __name__ == '__main__'`: 해당 파일 직접 실행 시만 실행되도록 제한

#### 6) CSV Jsonl 변환

#### products.csv

```csv
product_id,product_name,price,description
101,새우깡,1500,"손이 가는 짭짤한 맛"
102,감자깡,1600,"담백한 감자의 풍미가 그대로"
103,고구마깡,1600,"달콤하고 바삭한 맛"
```

#### main.py

```python
import os
from my_parser import convert_csv_to_json

def run_pipeline():
    """
        CSV to JSONL 변환 파이프라인을 실행하는 메인 함수
    """

    base_dir = os.path.dirname(os.path.abspath(__file__))

    input_csv_path = os.path.join(base_dir, 'data', 'products.csv')
    output_json_path = os.path.join(base_dir, 'products.jsonl')

    # 데이터 변환 실행
    is_success = convert_csv_to_json(input_csv_path, output_json_path)

    if is_success:
        print("작업 성공")
    else:
        print("작업 실패")

if __name__ == '__main__':
    run_pipeline()
```

- `os.path.join`: 플랫폼에 독립적인 경로 구성
- `from ... import`: 다른 파일에서 함수 재사용

#### my_parser.py

```python
import pandas as pd
import json

def convert_csv_to_json(csv_path: str, jsonl_path: str):
    """
        CSV 파일을 읽어와 각 행을 하나의 JSON 객체로 변환하여 
        JSON(JSON Lines) 파일로 저장하는 함수이다
    """
    try:
        df = pd.read_csv(csv_path, encoding='utf-8')  # CSV → DataFrame

        records = df.to_dict('records')  # DataFrame → 딕셔너리 리스트

        with open(jsonl_path, 'w', encoding='utf-8') as f:
            for record in records:
                json_string = json.dumps(record, ensure_ascii=False)
                f.write(json_string + '\n')  # JSONL 형식: 한 줄에 하나의 JSON

        return True
    except FileNotFoundError:
        print(f"파일을 찾을 수 없습니다")
        return False
    except Exception as e:
        print(f"파일 변환 중 문제가 발생했습니다 {e}")
        return False
```

- `pandas.read_csv()`: CSV 파일을 테이블 형태로 읽음
- `DataFrame.to_dict('records')`: 각 행을 딕셔너리로 변환
- `json.dumps()`: 딕셔너리를 문자열 형태로 변
- *JSONL: 한 줄에 하나의 JSON 객체를 저장하는 형식
