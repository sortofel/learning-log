### :link: 2025-08-29
- [프로젝트 개요 및 목표](#1-프로젝트-개요-및-목표)
- [주요 성과 및 구현 기능](#2-주요-성과-및-구현-기능)
- [핵심 코드](#3-핵심-코드)
- [회고 및 배운 점](#4-회고-및-배운-점)
- [프로젝트 링크](#5-프로젝트-링크)
 
&nbsp;   
이 문서는 약 2주간 진행되었던 프로젝트 `<Header>`의 2차 리팩토링에 대한 회고임.

### 1. 프로젝트 개요 및 목표

대한민국 뷰티샵의 67%에 달하는 소상공인들은 여전히 수기 장부로 고객을 관리하며 예약 누락, 정보 유실 등 많은 불편을 겪고 있습니다. 이 문제를 해결하기 위해, 뷰티샵 운영에 꼭 필요한 핵심 기능만을 담은 맞춤형 CRM 솔루션, `<Header>`를 기획하고 개발했다.

나는 이번 프로젝트에서 샵, 샵 휴일, 고객 예약 관리 기능을 개발했다.

- **샵/휴일 관리**: 샵 및 휴무 일정 생성, 조회, 수정, 삭제(비활성화)
- **고객 예약 관리**: 샵 검색 및 예약 생성, 조회, 취소   
 
&nbsp;  
### 2. 주요 성과 및 구현 기능

-  **안정적인 서비스 운영 기반 마련**
      - **동시성 제어**: 여러 사용자가 동시에 예약하는 상황에서 데이터 정합성을 보장하기 위해 **비관적 락(Pessimistic Lock)** 적용. 이를 통해 동시 요청 시 예약 성공률이 0%에서 100%(단일 성공)가 됐다.
      - **성능 최적화**: 반복 조회되는 휴무일 정보에 **Caffeine 로컬 캐시**를 도입, API 응답 속도를 **약 7배** 개선하며 서버 부하를 줄였다.
-  **지능형 챗봇 인터페이스 구축**
      - **사용자 의도 분석**: LLM의 **JSON 출력 모드**와 **프롬프트 엔지니어링**을 활용, "염색 잘하는 곳 찾아줘"와 같은 사용자의 자연어 요청에서 핵심 의도와 키워드를 추출하는 파이프라인을 구축했다.
-  **유지보수성을 고려한 코드 리팩토링**
      - **API 응답 구조 표준화**: 모든 컨트롤러에서 반복되던 응답 생성 코드를 `ShopApiResponse` 헬퍼 클래스로 모듈화하여 코드의 가독성과 재사용성을 높였다.   
 
&nbsp;  
### 3. 핵심 코드

**1. `ShopApiResponse` 헬퍼 클래스**   
컨트롤러의 코드를 간결하게 만들고, 프로젝트 전체의 API 응답 형식을 통일하기 위해 설계했다. 담당 도메인의 모든 응답 생성 로직이 이 클래스에 중앙화되어 있어 유지보수가 매우 용이해졌다.

```java
public class ShopApiResponse {

    // 데이터 조회 성공(200 OK) 응답을 생성하는 정적 메소드
    public static ResponseEntity<ResponseMessage> read(String dataKey, Object dataValue) {
        Map<String, Object> data = new HashMap<>();
        data.put(dataKey, dataValue);
        ResponseMessage responseMessage = new ResponseMessage(200, "조회 성공", data);
        return ResponseEntity.ok(responseMessage);
    }
}
```
&nbsp;   
**2. LLM의 사실 기반 추천을 위한 프롬프트**   
LLM이 부정확한 정보를 생성하는 것을 막기 위해, 실제 DB 데이터를 조회하여 프롬프트에 동적으로 주입하는 방식을 사용했다. 이를 통해 LLM이 주어진 사실 안에서만 답변을 생성하도록 유도했다.

```yaml
# 'intent_extraction' 프롬프트 일부
user_prompt: |
  당신은 전문 API 라우팅 어시스턴트입니다.
  당신의 임무는 사용자 요청을 분석하여 유효한 JSON 객체 하나만 반환하는 것입니다.
  
  ## 규칙:
  2. 요청이 '샵 카테고리'와 관련있으면, '사용 가능한 샵 카테고리' 목록에서 ... `categoryCode`를 설정하세요.
  3. 요청이 '메뉴'와 관련있으면, '사용 가능한 메뉴 키워드' 목록에서 ... `keyword`를 설정하세요.

  ## 사용 가능한 샵 카테고리:
  {shop_categories_json} # Spring 백엔드 API를 통해 동적으로 주입되는 데이터

  ## 사용 가능한 메뉴 키워드:
  {menu_keywords_list} # Spring 백엔드 API를 통해 동적으로 주입되는 데이터
  ---
  사용자 요청: {query}
```
 
&nbsp;  
### 4. 회고 및 배운 점

가장 기억에 남는 트러블 슈팅은 동시성 제어 전략을 수립하는 과정이었다.

처음에는 구현이 비교적 간단한 **낙관적 락**을 고려했다. 하지만 테스트 결과, 예약과 같이 충돌이 빈번하게 발생하는 시나리오에서는 여러 요청이 동시에 들어올 때 데이터 정합성이 깨지는 것을 확인했다.

결국 데이터 충돌 가능성을 원천적으로 차단하는 **비관적 락**으로 전략을 수정하고, DB에 **Unique 제약 조건**까지 추가하는 다층 방어 전략을 구축하게 되었다.

이 경험을 통해, 단순히 기술을 적용하는 것을 넘어 서비스의 특성과 예상되는 트래픽 패턴을 분석하여 적절한 기술을 선택하는 것이 얼마나 중요한지 깨달았다. 
 
&nbsp;  
### 5. 프로젝트 링크

-  [Backend](https://github.com/BOA-with-elephant/Header-backend)
- [Frontend](https://github.com/BOA-with-elephant/Header-Frontend)
- [기능 시연](https://youtu.be/6psPMJxH0DA)
