### :link: 2025-07-28
- [Python 기본 문법](#python-기본-문법)
 
&nbsp;
### Python 기본 문법
#### 1) 주석
* 한 줄 주석: `# 주석 내용`
* 여러 줄 주석: `''' 여러 줄 '''` 또는 `""" 여러 줄 """`

#### 2) 변수와 기본 타입

|예시|설명|
--|--
team_name = 'name'|문자열
price = 123_456| int (자릿수_구분_가능)
is_active = True| bool
user_data = None| null
f"문자열 {변수명}"|문자열 안에 변수 삽입 가능

#### 3) List (Java의 ArrayList)

|예시|설명|
--|--
scores = [88, 95, 56]|리스트 생성
scores[0]|요소 접근
append(value)|마지막 자리에 값 추가
insert(index, value)|index 위치에 value 추가
pop()|값 제거 및 반환, 마지막 인덱스가 기본값


#### 4) Dictionary (Java의 HashMap)

* 선언   
&emsp;:  `user = {'name': 'cillian', 'age': 'unknown'}`
* 요소 접근:   
    &emsp; : `user['name']`   
    &emsp; &nbsp; `user.get('email', '정보 없음')` : 기본값을 부여해 가져올 값이 없을 경우의 error 방지
* 수정/추가    
&emsp; : `user['job'] = 'actor'`
* 딕셔너리 리스트 예시:   
&emsp; : `users = [{'name': 'damon'}, {...}]`

---

#### 5) 얕은 복사 vs 깊은 복사

* 얕은 복사  
&emsp; : `b = a` → 주소값 복사
* 깊은 복사
&emsp; : `b = a.copy()` → 값을 복사해 새로운 객체 생성

---

#### 6) 문자열 처리

* 슬라이싱    
&emsp; : `txt[:5]` 시작 생략 = 처음부터, 끝 생략 = 마지막까지   
&emsp; &nbsp; `txt[::-1]` 시작과 끝 생략 = 처음부터 끝까지, step -1로 주면 문자열 뒤집음 (step=건너뛰기)
* 나누기   
    &emsp;: `.split(',')` 문자열을 특정 기준으로 나눠 리스트 생성 (csv에 사용)

---

#### 7) 제어문

* `if`, `elif`, `else` 사용 (Java의 `if-else`와 유사하나, 중괄호 대신 들여쓰기 사용)
* `for`문: 리스트, 딕셔너리 등 순회 가능

```python
for k, v in dict.items(): 
    #.items()는 key와 value를 한 쌍으로 반환, 가장 일반적으로 사용
    # keys()는 key 값만 반환
    # values()는 value 값만 반환
    print(k, v)
```

#### 8) List / Dict Comprehension

* List: `[결과표현식 for 아이템 in 리스트 if 조건]`
```py
# 1부터 10까지 제곱수로 이루어진 리스트 만들기
squares = [n**2 for n in range(1, 11) if n <= 5] # range(1부터 11 전까지)
```
* Dict: `{키_표현식: 값_표현식 for 아이템 in 리스트}`
```py
student_names = ['damon', 'graham', 'alex']
# 이름: 이름길이로 구성된 딕셔너리 만들기
name_lenghts = {name: len(name) for name in student_names}
```
* Lambda: 익명 함수
```py
add = lambda a, b: a + b # lambda 매개변수: return값, 단독보단 list sort할 때 자주 쓰임
print(f"람다 함수 결과 : {add(10, 20)}")
```
* sort: `list.sort(정렬기준, 오름/내림차순)`
```py
students = [
    {'name': 'damon', 'score': 90},
    {'name': 'graham', 'score': 35},
    {'name': 'alex', 'score': 0}
]

students.sort(key=lambda s: s['score'], reverse=True) # srudents를 s라는 값으로 가져와서 정렬 기준을 설정해줌
print(f"성적순 정렬: {students}")
```

#### 9) Lambda

* 익명 함수: `lambda 매개변수: 결과값`
* 주로 `sort()` 등에서 사용

#### 10) 실습

* 인벤토리: 딕셔너리 리스트로 구성
* 조건 필터링: `for + if`, `comprehension`, `sort(lambda)` 조합으로 처리
```py
# 1. 캐릭터의 인벤토리 데이터를 '딕셔너리 리스트' 형태로 만드세요.
# inventory라는 이름의 리스트 변수를 만드세요


# 2. 아래 4개의 아이템 정보를 각각 딕셔너리로 만들어 inventory 리스트에 담으세요.

inventory = [
    {'name': 'healing_potion', 'type': 'potion', 'grade': 'common', 'price': 50},
    {'name': 'sword_of_legend', 'type': 'weapon', 'grade': 'legendary', 'price': 10000},
    {'name': 'iron_shield', 'type': 'armor', 'grade': 'rare', 'price': 1500},
    {'name': 'mana_potion', 'type': 'potion', 'grade': 'common', 'price': 40}
]

# 3. `for`문과 `if`문을 사용해 인벤토리에서 타입(`type`)이 'potion'인 아이템들의 **이름과 가격만** 형식에 맞춰 출력하세요.

for item in inventory:
    if 'potion' in item['type']:
        print(f"물약 정보 : {item['name']} (가격 : {item['price']} G)")

# 물약 정보: healing_potion (가격: 50 G)
# 물약 정보: mana_potion (가격: 40 G)

# 4. 등급(grade)이 'rare' 이상인 아이템들의 이름만 뽑아서 새로운 리스트를 만드세요.
# 이때, List Comprehension을 사용해서 단 한 줄로 해결해 보세요.

valuable_items = [item['name'] for item in inventory if item['grade'] in 'rare' or item['grade'] in 'legendary']
print()
print(f"valuable_items: {valuable_items}")

# 5. 인벤토리의 모든 아이템을 가격(price)이 비싼 순서대로 정렬하여 출력하세요. list.sort() 메서드와 **lambda 함수**를 사용합니다.

items_to_sell = inventory.copy()
items_to_sell.sort(key=lambda p: p['price'], reverse=True)

print()
print("비싼 순 정렬")
for item in items_to_sell:
    print(f"{item['name']} (가격 : {item['price']} G)")
```

#### 11) AI API 요청

* 모듈: `requests`, `os`, `dotenv`
* `.env` + `os.getenv` → 보안 처리된 API 키 전달
* `.env` 파일을 통해 `api_key`를 로딩
* `requests.post()` + `json` 데이터 → 챗봇 요청 형식 구현
* 프롬프트 생성에 (f-string) 사용
* POST 요청 전송 및 응답 파싱 수행

* 오류 해결   
&emsp; : 환경 변수 설정이 자동으로 되지 않아 pip install이 python과 다른 경로에 설치됨.   
&emsp; 1) which python, which pip 로 경로가 다른 것을 확인   
&emsp; 2) [python 설치 경로] -m pip install python-dotenv로 설치  
&emsp; &nbsp; &nbsp; 추후 `python -m pip install [라이브러리 이름]` 형식으로 설치할 예정


```py
# requests: 파이썬으로 HTTP 요청을 쉽게 보낼 수 있게 해주는 라이브러리 pip install requests
import requests
# os: 운영체제와 상호작용하는 기능을 제공하는 내장 모듈 (환경 변수 접근 등)
import os
# dotenv: .env 파일에 정의된 변수를 환경 변수로 로드해주는 라이브러리 pip install python-dotenv (python -m pip...)
from dotenv import load_dotenv

# 1. 환경 변수 로드
# 같은 폴더나 상위 폴더에 있는 env 파일을 찾아 안의 내용을 시스템 환경 변수처럼 쓸 수 있게 메모리에 올려줌
load_dotenv()

# 2. API 키 안전하게 불러오기
api_key = os.getenv("OPENAI_API_KEY")

if not api_key:
    raise ValueError("OPENAI_API_KEY 환경 변수가 설정되지 않았습니다.")

# 3. API 요청 정보 설정
api_url = "https://api.openai.com/v1/chat/completions"

# HTTP 요청 헤더
headers = {
    "Authorization": f"Bearer {api_key}",
    "Content-Type": "application/json"
}

data = {
    "model": "gpt-3.5-turbo", # 사용할 LLM 모델
    "messages": [ # 대화 내용을 담는 리스트
        {
            "role": "user",
            "content": "파이썬의 f-string에 대해 30자 이내로 설명해줘."
        }
    ],
    "temperature": 0.7 # 답변의 창의성을 조절하는 값 (0~2)
}

# 4. API 요청 보내기 및 응답 처리

# API에 POST 요청을 보낸다.
# json=data 옵션은 딕셔녀리를 자동으로 json 문자열로 변환하고, 헤더에 맞게 전송해준다.
response = requests.post(api_url, headers=headers, json=data)

# 200번대 성공 코드가 아닐 경우, 에러를 발생시킨다.
response.raise_for_status()

# 5. 응답 파싱
# 응답받은 json 문자열을 파이썬 딕셔너리로 변환
result = response.json()

import json
print(json.dumps(result, indent=2, ensure_ascii=False))

answer = result['choices'][0]['message']['content']
print("LLM의 답변:")
print(answer)

# LLM의 답변:
# f-string은 파이썬의 문자열 formatting 방법 중 하나로, 문자열 앞에 'f'를 붙여 변수나 표현식을 쉽게 삽입할 수 있게 해준다.

```
